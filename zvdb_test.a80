; MinZ generated code
; Generated: 2025-08-02 22:04:33


; Data section
    ORG $F000

zvdb_test.tests_passed:
    DB 0
zvdb_test.tests_failed:
    DB 0
str_0:
    DB 13    ; Length
    DB 195
    DB 162
    DB 194
    DB 156
    DB 194
    DB 147
    DB " "
str_1:
    DB 13    ; Length
    DB 195
    DB 162
    DB 194
    DB 156
    DB 194
    DB 151
    DB " "
str_2:
    DB 12    ; Length
    DB ": FAIL (got "
str_3:
    DB 11    ; Length
    DB ", expected "
str_4:
    DB 24    ; Length
    DB 10
    DB "=== Popcount Tests ==="
    DB 10
str_5:
    DB 14    ; Length
    DB "popcount(0x00)"
str_6:
    DB 14    ; Length
    DB "popcount(0x01)"
str_7:
    DB 14    ; Length
    DB "popcount(0x03)"
str_8:
    DB 14    ; Length
    DB "popcount(0x0F)"
str_9:
    DB 14    ; Length
    DB "popcount(0x55)"
str_10:
    DB 14    ; Length
    DB "popcount(0xAA)"
str_11:
    DB 14    ; Length
    DB "popcount(0xFF)"
str_12:
    DB 32    ; Length
    DB 10
    DB "=== Hamming Distance Tests ==="
    DB 10
str_13:
    DB 17    ; Length
    DB "Identical vectors"
str_14:
    DB 16    ; Length
    DB "Opposite vectors"
str_15:
    DB 14    ; Length
    DB "Half different"
str_16:
    DB 17    ; Length
    DB "One bit different"
str_17:
    DB 32    ; Length
    DB 10
    DB "=== Similarity Score Tests ==="
    DB 10
str_18:
    DB 20    ; Length
    DB "Identical similarity"
str_19:
    DB 33    ; Length
    DB 226
    DB 156
    DB 147
    DB " Opposite similarity: PASS"
    DB 10
str_20:
    DB 33    ; Length
    DB 226
    DB 156
    DB 151
    DB " Opposite similarity: FAIL"
    DB 10
str_21:
    DB 12    ; Length
    DB "Half similar"
str_22:
    DB 29    ; Length
    DB 10
    DB "=== Vector Search Tests ==="
    DB 10
str_23:
    DB 16    ; Length
    DB "Find exact match"
str_24:
    DB 12    ; Length
    DB "Find nearest"
str_25:
    DB 20    ; Length
    DB "ZVDB E2E Test Suite"
    DB 10
str_26:
    DB 19    ; Length
    DB "=================="
    DB 10
str_27:
    DB 22    ; Length
    DB 10
    DB "=== Test Summary ==="
    DB 10
str_28:
    DB 26    ; Length
    DB 10
    DB 226
    DB 156
    DB 133
    DB " All tests passed!"
    DB 10
str_29:
    DB 27    ; Length
    DB 10
    DB 226
    DB 157
    DB 140
    DB " Some tests failed!"
    DB 10

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.assert_equal
zvdb_test.assert_equal:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
zvdb_test.assert_equal_param_actual:
    LD HL, #0000   ; SMC parameter actual
    LD ($F008), HL    ; Virtual register 4 to memory
zvdb_test.assert_equal_param_expected:
    LD DE, #0000   ; SMC parameter expected
    EX DE, HL      ; Move to HL for storage
    LD D, H
    LD E, L
    ; r6 = r4 == r5
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD D, H
    LD E, L
    LD H, D
    LD L, E
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L1
    LD HL, 0
    JP .L2
.L1:
    LD HL, 1
.L2:
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; jump_if_not r6, else_1
    EXX               ; Switch to shadow registers
    LD A, L'         ; From shadow HL'
    EXX               ; Switch back to main registers
    OR A
    JP Z, else_1
    ; r7 = load tests_passed
    LD HL, ($F000)
    ; r8 = 1
    LD A, 1
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; r9 = r7 + r8
    LD D, H
    LD E, L
    ADD HL, DE
    ; store tests_passed, r9
    LD ($F000), HL
    ; r10 = string(str_0)
    LD HL, str_0
    ; Print "Ã¢ÂÂ " (13 chars via loop)
    CALL print_string
    ; Direct print ": PASS
" (7 chars)
    ; Direct print ": PASS
" (7 chars)
    LD A, 58
    RST 16             ; Print character
    LD A, 32
    RST 16             ; Print character
    LD A, 80
    RST 16             ; Print character
    LD A, 65
    RST 16             ; Print character
    LD A, 83
    RST 16             ; Print character
    LD A, 83
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; jump end_if_2
    JP end_if_2
    ; else_1:
else_1:
    ; r11 = load tests_failed
    LD HL, ($F000)
    ; r12 = 1
    LD A, 1
    LD ($F018), A     ; Virtual register 12 to memory
    ; r13 = r11 + r12
    LD D, H
    LD E, L
    LD HL, ($F018)    ; Virtual register 12 from memory
    ADD HL, DE
    ; store tests_failed, r13
    LD ($F000), HL
    ; r14 = string(str_1)
    LD HL, str_1
    ; Print "Ã¢ÂÂ " (13 chars via loop)
    CALL print_string
    ; r15 = string(str_2)
    LD HL, str_2
    ; Register 15 already in HL
    ; Print ": FAIL (got " (12 chars via loop)
    ; Register 15 already in HL
    CALL print_string
    ; r16 = string(str_3)
    LD HL, str_3
    ; Print ", expected " (11 chars via loop)
    CALL print_string
    ; Direct print ")
" (2 chars)
    ; Direct print ")
" (2 chars)
    LD A, 41
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; end_if_2:
end_if_2:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.test_popcount
zvdb_test.test_popcount:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -7
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r1 = string(str_4)
    LD HL, str_4
    ; Print "
=== Popcount Tests ===
" (24 chars via loop)
    CALL print_string
    ; r3 = 0
    LD A, 0
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F006)    ; Virtual register 3 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r4
    LD A, H
    LD (IX-1), A
    ; r5 = load pc0
    LD A, (IX-1)
    LD ($F00A), A     ; Virtual register 5 to memory
    ; r6 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; Load string "popcount(0x00)"
    LD HL, str_5
    ; r8 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    LD HL, ($F00A)    ; Virtual register 5 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    LD ($F010), HL    ; Virtual register 8 to memory
    ; r10 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r11 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r11
    LD A, L
    LD (IX-2), A
    ; r12 = load pc1
    LD A, (IX-2)
    LD H, A         ; Store to physical register H
    ; r13 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Load string "popcount(0x01)"
    LD HL, str_6
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; r15 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F01C)    ; Virtual register 14 from memory
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r17 = 3
    LD A, 3
    LD L, A         ; Store to physical register L
    ; r18 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    LD ($F024), HL    ; Virtual register 18 to memory
    ; store , r18
    LD A, ($F024)     ; Virtual register 18 from memory
    LD (IX-3), A
    ; r19 = load pc3
    LD A, (IX-3)
    LD L, A         ; Store to physical register L
    ; r20 = 2
    LD A, 2
    LD ($F028), A     ; Virtual register 20 to memory
    ; Load string "popcount(0x03)"
    LD HL, str_7
    ; r22 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    LD HL, ($F028)    ; Virtual register 20 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r24 = 15
    LD A, 15
    LD ($F030), A     ; Virtual register 24 to memory
    ; r25 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F030)    ; Virtual register 24 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r25
    LD A, H
    LD (IX-4), A
    ; r26 = load pcF
    LD A, (IX-4)
    LD ($F034), A     ; Virtual register 26 to memory
    ; r27 = 4
    LD A, 4
    LD H, A         ; Store to physical register H
    ; Load string "popcount(0x0F)"
    LD HL, str_8
    ; r29 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    LD HL, ($F034)    ; Virtual register 26 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; r31 = 85
    LD A, 85
    LD H, A         ; Store to physical register H
    ; r32 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r32
    LD A, L
    LD (IX-5), A
    ; r33 = load pc55
    LD A, (IX-5)
    LD H, A         ; Store to physical register H
    ; r34 = 4
    LD A, 4
    LD L, A         ; Store to physical register L
    ; Load string "popcount(0x55)"
    LD HL, str_9
    LD ($F046), HL    ; Virtual register 35 to memory
    ; r36 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F046)    ; Virtual register 35 from memory
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r38 = 170
    LD A, 170
    LD L, A         ; Store to physical register L
    ; r39 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    LD ($F04E), HL    ; Virtual register 39 to memory
    ; store , r39
    LD A, ($F04E)     ; Virtual register 39 from memory
    LD (IX-6), A
    ; r40 = load pcAA
    LD A, (IX-6)
    LD L, A         ; Store to physical register L
    ; r41 = 4
    LD A, 4
    LD ($F052), A     ; Virtual register 41 to memory
    ; Load string "popcount(0xAA)"
    LD HL, str_10
    ; r43 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    LD HL, ($F052)    ; Virtual register 41 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r45 = 255
    LD A, 255
    LD ($F05A), A     ; Virtual register 45 to memory
    ; r46 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F05A)    ; Virtual register 45 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r46
    LD A, H
    LD (IX-7), A
    ; r47 = load pcFF
    LD A, (IX-7)
    LD ($F05E), A     ; Virtual register 47 to memory
    ; r48 = 8
    LD A, 8
    LD H, A         ; Store to physical register H
    ; Load string "popcount(0xFF)"
    LD HL, str_11
    ; r50 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    LD HL, ($F05E)    ; Virtual register 47 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; Register 50 already in HL
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.popcount_bits
zvdb_test.popcount_bits:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; store , r3
    LD A, H
    LD ($F004), A
zvdb_test.popcount_bits_param_val:
    LD HL, #0000   ; SMC parameter val (u8->u16)
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; store , r5
    LD A, ($F00A)     ; Virtual register 5 from memory
    LD ($F008), A
    ; r6 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r7 = 8
    LD A, 8
    LD ($F00E), A     ; Virtual register 7 to memory
    ; Initialize loop variable i
    ; for_loop_3:
for_loop_3:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F00E)    ; Virtual register 7 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L3
    LD HL, 0
    JP .L4
.L3:
    LD HL, 1
.L4:
    ; jump_if_not r9, for_end_4
    LD A, L
    OR A
    JP Z, for_end_4
    ; r10 = load v
    LD A, ($F008)
    LD ($F014), A     ; Virtual register 10 to memory
    ; r11 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r12 = r10 & r11
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r13 = 0
    LD A, 0
    LD ($F01A), A     ; Virtual register 13 to memory
    ; r14 = r12 != r13
    LD D, H
    LD E, L
    LD HL, ($F01A)    ; Virtual register 13 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L5
    LD HL, 0
    JP .L6
.L5:
    LD HL, 1
.L6:
    ; jump_if_not r14, else_5
    LD A, H
    OR A
    JP Z, else_5
    ; r15 = load count
    LD A, ($F004)
    LD L, A         ; Store to physical register L
    ; r16 = 1
    LD A, 1
    LD ($F020), A     ; Virtual register 16 to memory
    ; r17 = r15 + r16
    LD D, H
    LD E, L
    LD HL, ($F020)    ; Virtual register 16 from memory
    ADD HL, DE
    ; store count, r17
    LD A, H
    LD ($F004), A
    ; jump end_if_6
    JP end_if_6
    ; else_5:
else_5:
    ; end_if_6:
end_if_6:
    ; r18 = load v
    LD A, ($F008)
    LD L, A         ; Store to physical register L
    ; r19 = 1
    LD A, 1
    LD ($F026), A     ; Virtual register 19 to memory
    ; r20 = r18 >> r19
    ; Shift right
    LD A, L
    LD B, A       ; B = value to shift
    LD A, ($F026)     ; Virtual register 19 from memory
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shr_done_6
    LD B, C       ; B = counter
.shr_loop_6:
    DEC B
    JP M, .shr_done_6
    SRL A         ; Shift right, 0 into bit 7
    JR .shr_loop_6
.shr_done_6:
    LD L, A
    LD H, 0
    ; store v, r20
    LD A, H
    LD ($F008), A
    ; r21 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_3
    JP for_loop_3
    ; for_end_4:
for_end_4:
    ; r22 = load count
    LD A, ($F004)
    LD L, A         ; Store to HL (low byte)
    ; return r22
    ; Register 22 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.test_hamming
zvdb_test.test_hamming:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = string(str_12)
    LD HL, str_12
    ; Print "
=== Hamming Distance Tests ===
" (32 chars via loop)
    CALL print_string
    ; r4 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r5 = 32
    LD A, 32
    LD ($F00A), A     ; Virtual register 5 to memory
    ; Initialize loop variable i
    ; for_loop_7:
for_loop_7:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F00A)    ; Virtual register 5 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L8
    LD HL, 0
    JP .L9
.L8:
    LD HL, 1
.L9:
    ; jump_if_not r7, for_end_8
    LD A, L
    OR A
    JP Z, for_end_8
    ; r8 = 85
    LD A, 85
    LD L, A         ; Store to HL (low byte)
    ; r9 = load v1
    LD HL, ($F004)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F014), HL    ; Virtual register 10 to memory
    ; r11 = load i
    LD HL, ($F000)
    ; Register 11 already in HL
    ; Calculate array element address
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD D, H
    LD E, L
    ; Register 11 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r13 = 85
    LD A, 85
    LD L, A         ; Store to physical register L
    ; r14 = load v2
    LD HL, ($F006)
    ; Register 14 already in HL
    ; Load field data (offset 0)
    ; Register 14 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; r16 = load i
    LD HL, ($F000)
    ; Register 16 already in HL
    ; Calculate array element address
    LD HL, ($F01E)    ; Virtual register 15 from memory
    LD D, H
    LD E, L
    ; Register 16 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r18 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_7
    JP for_loop_7
    ; for_end_8:
for_end_8:
    ; r20 = load v1
    LD HL, ($F004)
    LD ($F028), HL    ; Virtual register 20 to memory
    ; r21 = &r20
    ; Address-of operation for register r20
    LD HL, $F028  ; Variable address
    ; r22 = load v2
    LD HL, ($F006)
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F02E)    ; Virtual register 23 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    ; store , r24
    LD ($F026), HL
    ; r25 = load dist1
    LD HL, ($F026)
    LD ($F032), HL    ; Virtual register 25 to memory
    ; r26 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; Load string "Identical vectors"
    LD HL, str_13
    ; r28 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    LD HL, ($F032)    ; Virtual register 25 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    LD ($F038), HL    ; Virtual register 28 to memory
    ; r29 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r30 = 32
    LD A, 32
    LD L, A         ; Store to physical register L
    ; Initialize loop variable i
    LD ($F03E), HL    ; Virtual register 31 to memory
    ; for_loop_9:
for_loop_9:
    ; Check i < end
    LD HL, ($F03E)    ; Virtual register 31 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L10
    LD HL, 0
    JP .L11
.L10:
    LD HL, 1
.L11:
    ; jump_if_not r32, for_end_10
    LD A, H
    OR A
    JP Z, for_end_10
    ; r33 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r34 = load v1
    LD HL, ($F004)
    ; Register 34 already in HL
    ; Load field data (offset 0)
    ; Register 34 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F046), HL    ; Virtual register 35 to memory
    ; r36 = load i
    LD HL, ($F000)
    ; Register 36 already in HL
    ; Calculate array element address
    LD HL, ($F046)    ; Virtual register 35 from memory
    LD D, H
    LD E, L
    ; Register 36 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r38 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; r39 = load v2
    LD HL, ($F006)
    ; Register 39 already in HL
    ; Load field data (offset 0)
    ; Register 39 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F050), HL    ; Virtual register 40 to memory
    ; r41 = load i
    LD HL, ($F000)
    ; Register 41 already in HL
    ; Calculate array element address
    LD HL, ($F050)    ; Virtual register 40 from memory
    LD D, H
    LD E, L
    ; Register 41 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r43 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD HL, ($F03E)    ; Virtual register 31 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F03E), HL    ; Virtual register 31 to memory
    ; jump for_loop_9
    JP for_loop_9
    ; for_end_10:
for_end_10:
    ; r45 = load v1
    LD HL, ($F004)
    ; r46 = &r45
    ; Address-of operation for register r45
    LD HL, $F05A  ; Variable address
    ; r47 = load v2
    LD HL, ($F006)
    LD ($F05E), HL    ; Virtual register 47 to memory
    ; r48 = &r47
    ; Address-of operation for register r47
    LD HL, $F05E  ; Variable address
    ; r49 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    ; store , r49
    LD ($F058), HL
    ; r50 = load dist2
    LD HL, ($F058)
    ; r51 = 256
    LD HL, 256
    LD ($F066), HL    ; Virtual register 51 to memory
    ; Load string "Opposite vectors"
    LD HL, str_14
    LD ($F068), HL    ; Virtual register 52 to memory
    ; r53 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F068)    ; Virtual register 52 from memory
    PUSH HL       ; Argument 2
    LD HL, ($F066)    ; Virtual register 51 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r54 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r55 = 32
    LD A, 32
    LD ($F06E), A     ; Virtual register 55 to memory
    ; Initialize loop variable i
    ; for_loop_11:
for_loop_11:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F06E)    ; Virtual register 55 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L12
    LD HL, 0
    JP .L13
.L12:
    LD HL, 1
.L13:
    ; jump_if_not r57, for_end_12
    LD A, L
    OR A
    JP Z, for_end_12
    ; r58 = 15
    LD A, 15
    LD L, A         ; Store to HL (low byte)
    ; r59 = load v1
    LD HL, ($F004)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F078), HL    ; Virtual register 60 to memory
    ; r61 = load i
    LD HL, ($F000)
    ; Register 61 already in HL
    ; Calculate array element address
    LD HL, ($F078)    ; Virtual register 60 from memory
    LD D, H
    LD E, L
    ; Register 61 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r63 = 240
    LD A, 240
    LD L, A         ; Store to physical register L
    ; r64 = load v2
    LD HL, ($F006)
    ; Register 64 already in HL
    ; Load field data (offset 0)
    ; Register 64 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F082), HL    ; Virtual register 65 to memory
    ; r66 = load i
    LD HL, ($F000)
    ; Register 66 already in HL
    ; Calculate array element address
    LD HL, ($F082)    ; Virtual register 65 from memory
    LD D, H
    LD E, L
    ; Register 66 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r68 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_11
    JP for_loop_11
    ; for_end_12:
for_end_12:
    ; r70 = load v1
    LD HL, ($F004)
    LD ($F08C), HL    ; Virtual register 70 to memory
    ; r71 = &r70
    ; Address-of operation for register r70
    LD HL, $F08C  ; Variable address
    ; r72 = load v2
    LD HL, ($F006)
    ; r73 = &r72
    ; Address-of operation for register r72
    LD HL, $F090  ; Variable address
    LD ($F092), HL    ; Virtual register 73 to memory
    ; r74 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F092)    ; Virtual register 73 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    ; store , r74
    LD ($F08A), HL
    ; r75 = load dist3
    LD HL, ($F08A)
    ; Register 75 already in HL
    ; r76 = 256
    LD HL, 256
    LD ($F098), HL    ; Virtual register 76 to memory
    ; Load string "Half different"
    LD HL, str_15
    LD ($F09A), HL    ; Virtual register 77 to memory
    ; r78 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F09A)    ; Virtual register 77 from memory
    PUSH HL       ; Argument 2
    LD HL, ($F098)    ; Virtual register 76 from memory
    PUSH HL       ; Argument 1
    ; Register 75 already in HL
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r79 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r80 = 32
    LD A, 32
    LD ($F0A0), A     ; Virtual register 80 to memory
    ; Initialize loop variable i
    ; for_loop_13:
for_loop_13:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F0A0)    ; Virtual register 80 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L14
    LD HL, 0
    JP .L15
.L14:
    LD HL, 1
.L15:
    ; jump_if_not r82, for_end_14
    LD A, L
    OR A
    JP Z, for_end_14
    ; r83 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; r84 = load v1
    LD HL, ($F004)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0AA), HL    ; Virtual register 85 to memory
    ; r86 = load i
    LD HL, ($F000)
    ; Register 86 already in HL
    ; Calculate array element address
    LD HL, ($F0AA)    ; Virtual register 85 from memory
    LD D, H
    LD E, L
    ; Register 86 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r88 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r89 = load v2
    LD HL, ($F006)
    ; Register 89 already in HL
    ; Load field data (offset 0)
    ; Register 89 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0B4), HL    ; Virtual register 90 to memory
    ; r91 = load i
    LD HL, ($F000)
    ; Register 91 already in HL
    ; Calculate array element address
    LD HL, ($F0B4)    ; Virtual register 90 from memory
    LD D, H
    LD E, L
    ; Register 91 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r93 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_13
    JP for_loop_13
    ; for_end_14:
for_end_14:
    ; r94 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r95 = load v2
    LD HL, ($F006)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0C0), HL    ; Virtual register 96 to memory
    ; r97 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Calculate array element address
    LD HL, ($F0C0)    ; Virtual register 96 from memory
    LD D, H
    LD E, L
    ; Register 97 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r100 = load v1
    LD HL, ($F004)
    ; r101 = &r100
    ; Address-of operation for register r100
    LD HL, $F0C8  ; Variable address
    LD ($F0CA), HL    ; Virtual register 101 to memory
    ; r102 = load v2
    LD HL, ($F006)
    ; r103 = &r102
    ; Address-of operation for register r102
    LD HL, $F0CC  ; Variable address
    ; r104 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F0CA)    ; Virtual register 101 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    LD ($F0D0), HL    ; Virtual register 104 to memory
    ; store , r104
    LD HL, ($F0D0)    ; Virtual register 104 from memory
    LD ($F0C6), HL
    ; r105 = load dist4
    LD HL, ($F0C6)
    ; r106 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Load string "One bit different"
    LD HL, str_16
    ; r108 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    ; Register 106 already in HL
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.calc_hamming
zvdb_test.calc_hamming:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r4 = 0
    LD A, 0
    LD ($F008), A     ; Virtual register 4 to memory
    ; store , r4
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD ($F006), HL
    ; r5 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r6 = 32
    LD A, 32
    LD L, A         ; Store to HL (low byte)
    ; Initialize loop variable i
    ; for_loop_15:
for_loop_15:
    ; Check i < end
    LD D, H
    LD E, L
    ; Register 6 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L16
    LD HL, 0
    JP .L17
.L16:
    LD HL, 1
.L17:
    ; jump_if_not r8, for_end_16
    LD A, L
    OR A
    JP Z, for_end_16
; TSMC reference parameter v1
v1$immOP:
    LD HL, 0000      ; TSMC ref address for v1
v1$imm0 EQU v1$immOP+1
    LD ($F014), HL    ; Virtual register 10 to memory
    ; Load field data (offset 0)
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 11 already in HL
    ; r12 = load i
    LD HL, ($F000)
    ; Register 12 already in HL
    ; Load array element (u8)
    ; Register 11 already in HL
    PUSH HL
    LD A, L
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
; TSMC reference parameter v2
v2$immOP:
    LD HL, 0000      ; TSMC ref address for v2
v2$imm0 EQU v2$immOP+1
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load field data (offset 0)
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; r16 = load i
    LD HL, ($F000)
    ; Load array element (u8)
    LD HL, ($F01E)    ; Virtual register 15 from memory
    PUSH HL
    LD A, H
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to physical register L
    ; r18 = r13 ^ r17
    LD D, H
    LD E, L
    LD A, L
    XOR E
    LD L, A
    LD A, H
    XOR D
    LD H, A
    ; store , r18
    LD A, H
    LD ($F012), A
    ; r20 = load xor_val
    LD A, ($F012)
    LD ($F028), A     ; Virtual register 20 to memory
    ; r21 = call popcount_bits
    ; Call to popcount_bits (args: 1)
    ; Stack-based parameter passing
    LD HL, ($F028)    ; Virtual register 20 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.popcount_bits
    ; store , r21
    LD A, H
    LD ($F026), A
    ; r22 = load distance
    LD HL, ($F006)
    ; Register 22 already in HL
    ; r23 = load bits
    LD A, ($F026)
    LD H, A         ; Store to physical register H
    ; r24 = r22 + r23
    ; Register 22 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F030), HL    ; Virtual register 24 to memory
    ; store distance, r24
    LD HL, ($F030)    ; Virtual register 24 from memory
    LD ($F006), HL
    ; r25 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 25 already in HL
    ADD HL, DE
    ; jump for_loop_15
    JP for_loop_15
    ; for_end_16:
for_end_16:
    ; r26 = load distance
    LD HL, ($F006)
    ; return r26
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.test_similarity
zvdb_test.test_similarity:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -74
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r1 = string(str_17)
    LD HL, str_17
    ; Print "
=== Similarity Score Tests ===
" (32 chars via loop)
    CALL print_string
    ; r4 = 0
    LD A, 0
    LD ($F008), A     ; Virtual register 4 to memory
    ; r5 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F008)    ; Virtual register 4 from memory
    ; for_loop_17:
for_loop_17:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L18
    LD HL, 0
    JP .L19
.L18:
    LD HL, 1
.L19:
    ; Register 7 already in HL
    ; jump_if_not r7, for_end_18
    LD A, L
    OR A
    JP Z, for_end_18
    ; r8 = 170
    LD A, 170
    LD H, A         ; Store to physical register H
    ; r9 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F014), HL    ; Virtual register 10 to memory
    ; r11 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 11 already in HL
    ; Calculate array element address
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD D, H
    LD E, L
    ; Register 11 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r13 = 170
    LD A, 170
    LD L, A         ; Store to physical register L
    ; r14 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; Register 14 already in HL
    ; Load field data (offset 0)
    ; Register 14 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; r16 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 16 already in HL
    ; Calculate array element address
    LD HL, ($F01E)    ; Virtual register 15 from memory
    LD D, H
    LD E, L
    ; Register 16 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r18 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_17
    JP for_loop_17
    ; for_end_18:
for_end_18:
    ; r20 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    LD ($F028), HL    ; Virtual register 20 to memory
    ; r21 = &r20
    ; Address-of operation for register r20
    LD HL, $F028  ; Variable address
    ; r22 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = call calc_similarity
    ; Call to calc_similarity (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F02E)    ; Virtual register 23 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_similarity
    ; store , r24
    LD (IX-66), L
    LD (IX-65), H
    ; r26 = load sim1
    LD L, (IX-66)
    LD H, (IX-65)
    ; Register 26 already in HL
    ; store , r26
    ; Register 26 already in HL
    LD (IX-68), L
    LD (IX-67), H
    ; r27 = load sim1_u
    LD L, (IX-68)
    LD H, (IX-67)
    ; r28 = 256
    LD HL, 256
    LD ($F038), HL    ; Virtual register 28 to memory
    ; Load string "Identical similarity"
    LD HL, str_18
    LD ($F03A), HL    ; Virtual register 29 to memory
    ; r30 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F03A)    ; Virtual register 29 from memory
    PUSH HL       ; Argument 2
    LD HL, ($F038)    ; Virtual register 28 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r31 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r32 = 32
    LD A, 32
    LD ($F040), A     ; Virtual register 32 to memory
    ; Initialize loop variable i
    ; for_loop_19:
for_loop_19:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F040)    ; Virtual register 32 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L20
    LD HL, 0
    JP .L21
.L20:
    LD HL, 1
.L21:
    ; jump_if_not r34, for_end_20
    LD A, L
    OR A
    JP Z, for_end_20
    ; r35 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; r36 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F04A), HL    ; Virtual register 37 to memory
    ; r38 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 38 already in HL
    ; Calculate array element address
    LD HL, ($F04A)    ; Virtual register 37 from memory
    LD D, H
    LD E, L
    ; Register 38 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r40 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; r41 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; Register 41 already in HL
    ; Load field data (offset 0)
    ; Register 41 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F054), HL    ; Virtual register 42 to memory
    ; r43 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 43 already in HL
    ; Calculate array element address
    LD HL, ($F054)    ; Virtual register 42 from memory
    LD D, H
    LD E, L
    ; Register 43 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r45 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_19
    JP for_loop_19
    ; for_end_20:
for_end_20:
    ; r47 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    LD ($F05E), HL    ; Virtual register 47 to memory
    ; r48 = &r47
    ; Address-of operation for register r47
    LD HL, $F05E  ; Variable address
    ; r49 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; r50 = &r49
    ; Address-of operation for register r49
    LD HL, $F062  ; Variable address
    LD ($F064), HL    ; Virtual register 50 to memory
    ; r51 = call calc_similarity
    ; Call to calc_similarity (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F064)    ; Virtual register 50 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_similarity
    ; store , r51
    LD (IX-70), L
    LD (IX-69), H
    ; r52 = load sim2
    LD L, (IX-70)
    LD H, (IX-69)
    ; Register 52 already in HL
    ; r53 = 256
    LD HL, 256
    ; r54 = -r53
    XOR A         ; Clear A
    SUB L         ; 0 - L
    LD L, A
    LD A, 0
    SBC A, H      ; 0 - H with borrow
    LD H, A
    ; Register 54 already in HL
    ; r55 = r52 == r54
    ; Register 52 already in HL
    LD D, H
    LD E, L
    ; Register 54 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L22
    LD HL, 0
    JP .L23
.L22:
    LD HL, 1
.L23:
    LD ($F06E), HL    ; Virtual register 55 to memory
    ; jump_if_not r55, else_21
    LD A, ($F06E)     ; Virtual register 55 from memory
    OR A
    JP Z, else_21
    ; r56 = load tests_passed
    LD L, (IX+0)
    LD H, (IX+1)
    LD ($F070), HL    ; Virtual register 56 to memory
    ; r57 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r58 = r56 + r57
    LD HL, ($F070)    ; Virtual register 56 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    ; store tests_passed, r58
    LD (IX+0), L
    LD (IX+1), H
    ; r59 = string(str_19)
    LD HL, str_19
    LD ($F076), HL    ; Virtual register 59 to memory
    ; Print "â Opposite similarity: PASS
" (33 chars via loop)
    LD HL, ($F076)    ; Virtual register 59 from memory
    CALL print_string
    ; jump end_if_22
    JP end_if_22
    ; else_21:
else_21:
    ; r60 = load tests_failed
    LD L, (IX+0)
    LD H, (IX+1)
    ; r61 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r62 = r60 + r61
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F07C), HL    ; Virtual register 62 to memory
    ; store tests_failed, r62
    LD HL, ($F07C)    ; Virtual register 62 from memory
    LD (IX+0), L
    LD (IX+1), H
    ; r63 = string(str_20)
    LD HL, str_20
    ; Print "â Opposite similarity: FAIL
" (33 chars via loop)
    CALL print_string
    ; end_if_22:
end_if_22:
    ; r64 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r65 = 32
    LD A, 32
    LD ($F082), A     ; Virtual register 65 to memory
    ; Initialize loop variable i
    ; for_loop_23:
for_loop_23:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F082)    ; Virtual register 65 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L24
    LD HL, 0
    JP .L25
.L24:
    LD HL, 1
.L25:
    ; jump_if_not r67, for_end_24
    LD A, L
    OR A
    JP Z, for_end_24
    ; r68 = 15
    LD A, 15
    LD L, A         ; Store to HL (low byte)
    ; r69 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F08C), HL    ; Virtual register 70 to memory
    ; r71 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 71 already in HL
    ; Calculate array element address
    LD HL, ($F08C)    ; Virtual register 70 from memory
    LD D, H
    LD E, L
    ; Register 71 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r73 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r74 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; Register 74 already in HL
    ; Load field data (offset 0)
    ; Register 74 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F096), HL    ; Virtual register 75 to memory
    ; r76 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 76 already in HL
    ; Calculate array element address
    LD HL, ($F096)    ; Virtual register 75 from memory
    LD D, H
    LD E, L
    ; Register 76 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r78 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_23
    JP for_loop_23
    ; for_end_24:
for_end_24:
    ; r80 = load v1
    LD L, (IX-32)
    LD H, (IX-31)
    LD ($F0A0), HL    ; Virtual register 80 to memory
    ; r81 = &r80
    ; Address-of operation for register r80
    LD HL, $F0A0  ; Variable address
    ; r82 = load v2
    LD L, (IX-64)
    LD H, (IX-63)
    ; r83 = &r82
    ; Address-of operation for register r82
    LD HL, $F0A4  ; Variable address
    LD ($F0A6), HL    ; Virtual register 83 to memory
    ; r84 = call calc_similarity
    ; Call to calc_similarity (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F0A6)    ; Virtual register 83 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_similarity
    ; store , r84
    LD (IX-72), L
    LD (IX-71), H
    ; r86 = load sim3
    LD L, (IX-72)
    LD H, (IX-71)
    LD ($F0AC), HL    ; Virtual register 86 to memory
    ; store , r86
    LD HL, ($F0AC)    ; Virtual register 86 from memory
    LD (IX-74), L
    LD (IX-73), H
    ; r87 = load sim3_u
    LD L, (IX-74)
    LD H, (IX-73)
    ; r88 = 128
    LD A, 128
    LD L, A         ; Store to HL (low byte)
    ; Load string "Half similar"
    LD HL, str_21
    ; r90 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    ; Register 88 already in HL
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.calc_similarity
zvdb_test.calc_similarity:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
; TSMC reference parameter v1
v1$immOP:
    LD HL, 0000      ; TSMC ref address for v1
v1$imm0 EQU v1$immOP+1
    LD ($F008), HL    ; Virtual register 4 to memory
; TSMC reference parameter v2
v2$immOP:
    LD HL, 0000      ; TSMC ref address for v2
v2$imm0 EQU v2$immOP+1
    ; Register 5 already in HL
    ; r6 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    ; Register 5 already in HL
    PUSH HL       ; Argument 1
    LD HL, ($F008)    ; Virtual register 4 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; store , r6
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD ($F006), HL
    ; r8 = load hamming
    LD HL, ($F006)
    ; r9 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; r10 = r8 << r9
    ; 16-bit shift left
    LD A, L
    LD B, A       ; B = shift count
    OR A
    JR Z, .shl16_done_25
.shl16_loop_25:
    ADD HL, HL    ; Shift left by 1
    DJNZ .shl16_loop_25
.shl16_done_25:
    ; store , r10
    LD ($F00E), HL
    ; r11 = 256
    LD HL, 256
    ; Register 11 already in HL
    ; r12 = load doubled
    LD HL, ($F00E)
    ; Register 12 already in HL
    ; r13 = r11 - r12
    ; Register 11 already in HL
    LD D, H
    LD E, L
    ; Register 12 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    ; return r13
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.test_search
zvdb_test.test_search:
; Using stack-based locals (IX+offset)
    PUSH IX
    LD IX, SP
    LD HL, -198
    ADD HL, SP
    LD SP, HL
    ; Load parameters from registers
    ; r1 = string(str_22)
    LD HL, str_22
    ; Print "
=== Vector Search Tests ===
" (29 chars via loop)
    CALL print_string
    ; r3 = 0
    LD A, 0
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F006)    ; Virtual register 3 from memory
    ; for_loop_25:
for_loop_25:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L27
    LD HL, 0
    JP .L28
.L27:
    LD HL, 1
.L28:
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; jump_if_not r6, for_end_26
    LD A, ($F00C)     ; Virtual register 6 from memory
    OR A
    JP Z, for_end_26
    ; r7 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r8 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; r9 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb_test.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F014), A     ; Virtual register 10 to memory
    ; Load field data (offset 0)
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 11 already in HL
    ; r12 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 12 already in HL
    ; Calculate array element address
    ; Register 11 already in HL
    LD D, H
    LD E, L
    ; Register 12 already in HL
    ADD HL, DE
    LD ($F01A), HL    ; Virtual register 13 to memory
    ; Store to array[index] (u8)
    LD HL, ($F01A)    ; Virtual register 13 from memory
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r14 = 1
    LD A, 1
    LD ($F01C), A     ; Virtual register 14 to memory
    ; Increment i
    LD D, H
    LD E, L
    LD HL, ($F01C)    ; Virtual register 14 from memory
    ADD HL, DE
    ; jump for_loop_25
    JP for_loop_25
    ; for_end_26:
for_end_26:
    ; r15 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r16 = 32
    LD A, 32
    LD L, A         ; Store to physical register L
    ; Initialize loop variable i
    ; for_loop_27:
for_loop_27:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L29
    LD HL, 0
    JP .L30
.L29:
    LD HL, 1
.L30:
    ; jump_if_not r18, for_end_28
    LD A, H
    OR A
    JP Z, for_end_28
    ; r19 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; r20 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; Register 20 already in HL
    ; r21 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; Load array element (zvdb_test.Vector256)
    ; Register 20 already in HL
    PUSH HL
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F02C), A     ; Virtual register 22 to memory
    ; Load field data (offset 0)
    LD HL, ($F02C)    ; Virtual register 22 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 23 already in HL
    ; r24 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 24 already in HL
    ; Calculate array element address
    ; Register 23 already in HL
    LD D, H
    LD E, L
    ; Register 24 already in HL
    ADD HL, DE
    LD ($F032), HL    ; Virtual register 25 to memory
    ; Store to array[index] (u8)
    LD HL, ($F032)    ; Virtual register 25 from memory
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r26 = 1
    LD A, 1
    LD ($F034), A     ; Virtual register 26 to memory
    ; Increment i
    LD D, H
    LD E, L
    LD HL, ($F034)    ; Virtual register 26 from memory
    ADD HL, DE
    ; jump for_loop_27
    JP for_loop_27
    ; for_end_28:
for_end_28:
    ; r27 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r28 = 32
    LD A, 32
    LD ($F038), A     ; Virtual register 28 to memory
    ; Initialize loop variable i
    ; for_loop_29:
for_loop_29:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F038)    ; Virtual register 28 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L31
    LD HL, 0
    JP .L32
.L31:
    LD HL, 1
.L32:
    ; jump_if_not r30, for_end_30
    LD A, L
    OR A
    JP Z, for_end_30
    ; r31 = 85
    LD A, 85
    LD L, A         ; Store to HL (low byte)
    ; r32 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; r33 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; Load array element (zvdb_test.Vector256)
    PUSH HL
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F044), A     ; Virtual register 34 to memory
    ; Load field data (offset 0)
    LD HL, ($F044)    ; Virtual register 34 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 35 already in HL
    ; r36 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 36 already in HL
    ; Calculate array element address
    ; Register 35 already in HL
    LD D, H
    LD E, L
    ; Register 36 already in HL
    ADD HL, DE
    LD ($F04A), HL    ; Virtual register 37 to memory
    ; Store to array[index] (u8)
    LD HL, ($F04A)    ; Virtual register 37 from memory
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r38 = 1
    LD A, 1
    LD ($F04C), A     ; Virtual register 38 to memory
    ; Increment i
    LD D, H
    LD E, L
    LD HL, ($F04C)    ; Virtual register 38 from memory
    ADD HL, DE
    ; jump for_loop_29
    JP for_loop_29
    ; for_end_30:
for_end_30:
    ; r39 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r40 = 32
    LD A, 32
    LD L, A         ; Store to physical register L
    ; Initialize loop variable i
    ; for_loop_31:
for_loop_31:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L33
    LD HL, 0
    JP .L34
.L33:
    LD HL, 1
.L34:
    ; jump_if_not r42, for_end_32
    LD A, H
    OR A
    JP Z, for_end_32
    ; r43 = 170
    LD A, 170
    LD L, A         ; Store to physical register L
    ; r44 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; Register 44 already in HL
    ; r45 = 3
    LD A, 3
    LD H, A         ; Store to physical register H
    ; Load array element (zvdb_test.Vector256)
    ; Register 44 already in HL
    PUSH HL
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F05C), A     ; Virtual register 46 to memory
    ; Load field data (offset 0)
    LD HL, ($F05C)    ; Virtual register 46 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 47 already in HL
    ; r48 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 48 already in HL
    ; Calculate array element address
    ; Register 47 already in HL
    LD D, H
    LD E, L
    ; Register 48 already in HL
    ADD HL, DE
    LD ($F062), HL    ; Virtual register 49 to memory
    ; Store to array[index] (u8)
    LD HL, ($F062)    ; Virtual register 49 from memory
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r50 = 1
    LD A, 1
    LD ($F064), A     ; Virtual register 50 to memory
    ; Increment i
    LD D, H
    LD E, L
    LD HL, ($F064)    ; Virtual register 50 from memory
    ADD HL, DE
    ; jump for_loop_31
    JP for_loop_31
    ; for_end_32:
for_end_32:
    ; r52 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r53 = 32
    LD A, 32
    LD ($F06A), A     ; Virtual register 53 to memory
    ; Initialize loop variable i
    ; for_loop_33:
for_loop_33:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F06A)    ; Virtual register 53 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L35
    LD HL, 0
    JP .L36
.L35:
    LD HL, 1
.L36:
    ; jump_if_not r55, for_end_34
    LD A, L
    OR A
    JP Z, for_end_34
    ; r56 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; r57 = load query1
    LD L, (IX-160)
    LD H, (IX-159)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F074), HL    ; Virtual register 58 to memory
    ; r59 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 59 already in HL
    ; Calculate array element address
    LD HL, ($F074)    ; Virtual register 58 from memory
    LD D, H
    LD E, L
    ; Register 59 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r61 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_33
    JP for_loop_33
    ; for_end_34:
for_end_34:
    ; r63 = load query1
    LD L, (IX-160)
    LD H, (IX-159)
    LD ($F07E), HL    ; Virtual register 63 to memory
    ; r64 = &r63
    ; Address-of operation for register r63
    LD HL, $F07E  ; Variable address
    ; r65 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; r66 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb_test.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r68 = &r67
    ; Address-of operation for register r67
    LD HL, $F086  ; Variable address
    LD ($F088), HL    ; Virtual register 68 to memory
    ; r69 = 4
    LD A, 4
    LD L, A         ; Store to physical register L
    ; r70 = call find_nearest
    ; Call to find_nearest (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    LD HL, ($F088)    ; Virtual register 68 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.find_nearest
    LD ($F08C), HL    ; Virtual register 70 to memory
    ; store , r70
    LD A, ($F08C)     ; Virtual register 70 from memory
    LD (IX-161), A
    ; r72 = load best1
    LD A, (IX-161)
    LD L, A         ; Store to physical register L
    ; store , r72
    LD (IX-163), L
    LD (IX-162), H
    ; r73 = load best1_u
    LD L, (IX-163)
    LD H, (IX-162)
    ; r74 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; Load string "Find exact match"
    LD HL, str_23
    LD ($F096), HL    ; Virtual register 75 to memory
    ; r76 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    LD HL, ($F096)    ; Virtual register 75 from memory
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; r78 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r79 = 32
    LD A, 32
    LD ($F09E), A     ; Virtual register 79 to memory
    ; Initialize loop variable i
    ; for_loop_35:
for_loop_35:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F09E)    ; Virtual register 79 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L37
    LD HL, 0
    JP .L38
.L37:
    LD HL, 1
.L38:
    ; jump_if_not r81, for_end_36
    LD A, L
    OR A
    JP Z, for_end_36
    ; r82 = 84
    LD A, 84
    LD L, A         ; Store to HL (low byte)
    ; r83 = load query2
    LD L, (IX-195)
    LD H, (IX-194)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F0A8), HL    ; Virtual register 84 to memory
    ; r85 = load i
    LD L, (IX+0)
    LD H, (IX+1)
    ; Register 85 already in HL
    ; Calculate array element address
    LD HL, ($F0A8)    ; Virtual register 84 from memory
    LD D, H
    LD E, L
    ; Register 85 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r87 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_35
    JP for_loop_35
    ; for_end_36:
for_end_36:
    ; r89 = load query2
    LD L, (IX-195)
    LD H, (IX-194)
    LD ($F0B2), HL    ; Virtual register 89 to memory
    ; r90 = &r89
    ; Address-of operation for register r89
    LD HL, $F0B2  ; Variable address
    ; r91 = load db
    LD L, (IX-128)
    LD H, (IX-127)
    ; r92 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb_test.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r94 = &r93
    ; Address-of operation for register r93
    LD HL, $F0BA  ; Variable address
    LD ($F0BC), HL    ; Virtual register 94 to memory
    ; r95 = 4
    LD A, 4
    LD L, A         ; Store to physical register L
    ; r96 = call find_nearest
    ; Call to find_nearest (args: 3)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 2
    LD HL, ($F0BC)    ; Virtual register 94 from memory
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.find_nearest
    LD ($F0C0), HL    ; Virtual register 96 to memory
    ; store , r96
    LD A, ($F0C0)     ; Virtual register 96 from memory
    LD (IX-196), A
    ; r98 = load best2
    LD A, (IX-196)
    LD L, A         ; Store to physical register L
    ; store , r98
    LD (IX-198), L
    LD (IX-197), H
    ; r99 = load best2_u
    LD L, (IX-198)
    LD H, (IX-197)
    ; r100 = 2
    LD A, 2
    LD L, A         ; Store to physical register L
    ; Load string "Find nearest"
    LD HL, str_24
    ; Register 101 already in HL
    ; r102 = call assert_equal
    ; Call to assert_equal (args: 3)
    ; Stack-based parameter passing
    ; Register 101 already in HL
    PUSH HL       ; Argument 2
    PUSH HL       ; Argument 1
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.assert_equal
    ; return
    LD SP, IX
    POP IX
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.find_nearest
zvdb_test.find_nearest:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r5 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; store , r5
    LD A, L
    LD ($F008), A
    ; r7 = 65535
    LD HL, 65535
    ; store , r7
    LD ($F00C), HL
    ; r8 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
zvdb_test.find_nearest_param_count:
    LD BC, #0000   ; SMC parameter count (u8->u16)
    LD H, B
    LD L, C        ; Move to HL for storage
    ; Initialize loop variable i
    ; for_loop_37:
for_loop_37:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L39
    LD HL, 0
    JP .L40
.L39:
    LD HL, 1
.L40:
    ; Register 11 already in HL
    ; jump_if_not r11, for_end_38
    LD A, L
    OR A
    JP Z, for_end_38
; TSMC reference parameter query
query$immOP:
    LD HL, 0000      ; TSMC ref address for query
query$imm0 EQU query$immOP+1
    LD ($F01A), HL    ; Virtual register 13 to memory
; TSMC reference parameter db
db$immOP:
    LD HL, 0000      ; TSMC ref address for db
db$imm0 EQU db$immOP+1
    ; Register 14 already in HL
    ; r15 = load i
    LD HL, ($F000)
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; Load array element (u8)
    ; Register 14 already in HL
    PUSH HL
    LD A, ($F01E)     ; Virtual register 15 from memory
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r17 = &r16
    ; Address-of operation for register r16
    LD HL, $F020  ; Variable address
    ; r18 = call calc_hamming
    ; Call to calc_hamming (args: 2)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 1
    LD HL, ($F01A)    ; Virtual register 13 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.calc_hamming
    LD ($F024), HL    ; Virtual register 18 to memory
    ; store , r18
    LD HL, ($F024)    ; Virtual register 18 from memory
    LD ($F018), HL
    ; r19 = load dist
    LD HL, ($F018)
    ; r20 = load best_dist
    LD HL, ($F00C)
    ; Register 20 already in HL
    ; r21 = r19 < r20
    LD D, H
    LD E, L
    ; Register 20 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L41
    LD HL, 0
    JP .L42
.L41:
    LD HL, 1
.L42:
    LD ($F02A), HL    ; Virtual register 21 to memory
    ; jump_if_not r21, else_39
    LD A, ($F02A)     ; Virtual register 21 from memory
    OR A
    JP Z, else_39
    ; r22 = load dist
    LD HL, ($F018)
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; store best_dist, r22
    LD HL, ($F02C)    ; Virtual register 22 from memory
    LD ($F00C), HL
    ; r23 = load i
    LD HL, ($F000)
    ; store best_id, r23
    LD A, L
    LD ($F008), A
    ; jump end_if_40
    JP end_if_40
    ; else_39:
else_39:
    ; end_if_40:
end_if_40:
    ; r24 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 24 already in HL
    ADD HL, DE
    ; jump for_loop_37
    JP for_loop_37
    ; for_end_38:
for_end_38:
    ; r25 = load best_id
    LD A, ($F008)
    LD H, A         ; Store to physical register H
    ; return r25
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb_test.main
zvdb_test.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = string(str_25)
    LD HL, str_25
    ; Print "ZVDB E2E Test Suite
" (20 chars via loop)
    CALL print_string
    ; r2 = string(str_26)
    LD HL, str_26
    LD ($F004), HL    ; Virtual register 2 to memory
    ; Print "==================
" (19 chars via loop)
    LD HL, ($F004)    ; Virtual register 2 from memory
    CALL print_string
    ; r3 = call test_popcount
    ; Call to test_popcount (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.test_popcount
    ; r4 = call test_hamming
    ; Call to test_hamming (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.test_hamming
    ; r5 = call test_similarity
    ; Call to test_similarity (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.test_similarity
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; r6 = call test_search
    ; Call to test_search (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb_test.test_search
    ; r7 = string(str_27)
    LD HL, str_27
    ; Print "
=== Test Summary ===
" (22 chars via loop)
    CALL print_string
    ; Direct print "Passed: " (8 chars)
    ; Direct print "Passed: " (8 chars)
    LD A, 80
    RST 16             ; Print character
    LD A, 97
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 101
    RST 16             ; Print character
    LD A, 100
    RST 16             ; Print character
    LD A, 58
    RST 16             ; Print character
    LD A, 32
    RST 16             ; Print character
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; Direct print "Failed: " (8 chars)
    ; Direct print "Failed: " (8 chars)
    LD A, 70
    RST 16             ; Print character
    LD A, 97
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 108
    RST 16             ; Print character
    LD A, 101
    RST 16             ; Print character
    LD A, 100
    RST 16             ; Print character
    LD A, 58
    RST 16             ; Print character
    LD A, 32
    RST 16             ; Print character
    ; Direct print "
" (1 chars)
    ; Direct print "
" (1 chars)
    LD A, 10
    RST 16             ; Print character
    ; r8 = load tests_failed
    LD HL, ($F000)
    LD ($F010), HL    ; Virtual register 8 to memory
    ; r9 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r10 = r8 == r9
    LD HL, ($F010)    ; Virtual register 8 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L43
    LD HL, 0
    JP .L44
.L43:
    LD HL, 1
.L44:
    ; jump_if_not r10, else_41
    LD A, L
    OR A
    JP Z, else_41
    ; r11 = string(str_28)
    LD HL, str_28
    ; Register 11 already in HL
    ; Print "
â All tests passed!
" (26 chars via loop)
    ; Register 11 already in HL
    CALL print_string
    ; jump end_if_42
    JP end_if_42
    ; else_41:
else_41:
    ; r12 = string(str_29)
    LD HL, str_29
    ; Print "
â Some tests failed!
" (27 chars via loop)
    CALL print_string
    ; end_if_42:
end_if_42:
    ; return
    RET

; Runtime print helper functions
print_string:
    LD B, (HL)         ; B = length from first byte
    INC HL             ; HL -> string data
    LD A, B            ; Check if length is zero
    OR A
    RET Z              ; Return if empty string
print_loop:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DJNZ print_loop    ; Decrement B and loop
    RET

print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET

print_i8_decimal:
    BIT 7, A           ; Check sign bit
    JR Z, print_u8_decimal
    PUSH AF
    LD A, '-'          ; Print minus sign
    RST 16
    POP AF
    NEG                ; Make positive
    JR print_u8_decimal

print_i16_decimal:
    BIT 7, H           ; Check sign bit
    JR Z, print_u16_decimal
    PUSH HL
    LD A, '-'          ; Print minus sign
    RST 16
    POP HL
    LD A, H            ; Negate HL
    CPL
    LD H, A
    LD A, L
    CPL
    LD L, A
    INC HL
    JR print_u16_decimal

print_bool:
    OR A               ; Test if A is zero
    JR NZ, print_true
    LD HL, bool_false_str
    JR print_string
print_true:
    LD HL, bool_true_str
    JR print_string

bool_true_str:
    DB 4, "true"      ; Length + data
bool_false_str:
    DB 5, "false"     ; Length + data


    END main
