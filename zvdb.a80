; MinZ generated code
; Generated: 2025-08-02 22:04:33


; Data section
    ORG $F000

zvdb.vectors:
    DS 512
zvdb.count:
    DB 0
zvdb.lut:
    DS 256
str_0:
    DB 27    ; Length
    DB "ZVDB-MinZ Production Ready"
    DB 10
str_1:
    DB 28    ; Length
    DB "=========================="
    DB 10
    DB 10
str_2:
    DB 20    ; Length
    DB "Initializing LUT..."
    DB 10
str_3:
    DB 25    ; Length
    DB "Creating test vectors..."
    DB 10
str_4:
    DB 13    ; Length
    DB "Database has "
str_5:
    DB 10    ; Length
    DB " vectors"
    DB 10
    DB 10
str_6:
    DB 19    ; Length
    DB "Hamming distances:"
    DB 10
str_7:
    DB 12    ; Length
    DB "  V0 vs V1: "
str_8:
    DB 12    ; Length
    DB "  V0 vs V2: "
str_9:
    DB 14    ; Length
    DB 10
    DB "Searching..."
    DB 10
str_10:
    DB 28    ; Length
    DB 10
    DB 226
    DB 156
    DB 133
    DB " ZVDB-MinZ Complete!"
    DB 10

; Code section
    ORG $8000

; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.init_lut
zvdb.init_lut:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = 0
    LD A, 0
    ; Register 1 already in A
    ; r2 = 256
    LD HL, 256
    LD ($F004), HL    ; Virtual register 2 to memory
    ; Initialize loop variable i
    ; for_loop_1:
for_loop_1:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F004)    ; Virtual register 2 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L1
    LD HL, 0
    JP .L2
.L1:
    LD HL, 1
.L2:
    ; jump_if_not r4, for_end_2
    LD A, C
    OR A
    JP Z, for_end_2
    ; r6 = load i
    LD HL, ($F000)
    ; store , r6
    LD A, D
    LD ($F00A), A
    ; r8 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD B', A         ; Store to shadow B'
    EXX               ; Switch back to main registers
    ; store , r8
    EXX               ; Switch to shadow registers
    LD A, B'         ; From shadow B'
    EXX               ; Switch back to main registers
    LD ($F00E), A
    ; r9 = 0
    LD A, 0
    EXX               ; Switch to shadow registers
    LD D', A         ; Store to shadow D'
    EXX               ; Switch back to main registers
    ; r10 = 8
    LD A, 8
    EXX               ; Switch to shadow registers
    LD E', A         ; Store to shadow E'
    EXX               ; Switch back to main registers
    ; Initialize loop variable b
    ; for_loop_3:
for_loop_3:
    ; Check b < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L3
    LD HL, 0
    JP .L4
.L3:
    LD HL, 1
.L4:
    ; jump_if_not r12, for_end_4
    LD A, H
    OR A
    JP Z, for_end_4
    ; r13 = load val
    LD A, ($F00A)
    LD L, A         ; Store to physical register L
    ; r14 = 1
    LD A, 1
    LD ($F01C), A     ; Virtual register 14 to memory
    ; r15 = load b
    LD HL, ($F000)
    ; r16 = r14 << r15
    ; Shift left
    LD A, ($F01C)     ; Virtual register 14 from memory
    LD B, A       ; B = value to shift
    LD A, H
    LD C, A       ; C = shift count
    LD A, B       ; A = value
    OR A          ; Clear carry
    JR Z, .shl_done_4
    LD B, C       ; B = counter
.shl_loop_4:
    DEC B
    JP M, .shl_done_4
    SLA A         ; Shift left, 0 into bit 0
    JR .shl_loop_4
.shl_done_4:
    LD L, A
    LD H, 0
    ; r17 = r13 & r16
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r18 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r19 = r17 != r18
    LD HL, ($F022)    ; Virtual register 17 from memory
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP NZ, .L6
    LD HL, 0
    JP .L7
.L6:
    LD HL, 1
.L7:
    ; jump_if_not r19, else_5
    LD A, L
    OR A
    JP Z, else_5
    ; r20 = load bits
    LD A, ($F00E)
    LD ($F028), A     ; Virtual register 20 to memory
    ; r21 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r22 = r20 + r21
    LD HL, ($F028)    ; Virtual register 20 from memory
    LD D, H
    LD E, L
    ADD HL, DE
    ; store bits, r22
    LD A, L
    LD ($F00E), A
    ; jump end_if_6
    JP end_if_6
    ; else_5:
else_5:
    ; end_if_6:
end_if_6:
    ; r23 = 1
    LD A, 1
    LD ($F02E), A     ; Virtual register 23 to memory
    ; Increment b
    LD D, H
    LD E, L
    LD HL, ($F02E)    ; Virtual register 23 from memory
    ADD HL, DE
    ; jump for_loop_3
    JP for_loop_3
    ; for_end_4:
for_end_4:
    ; r24 = load bits
    LD A, ($F00E)
    LD L, A         ; Store to physical register L
    ; r25 = load lut
    LD HL, ($F000)
    ; Register 25 already in HL
    ; r26 = load i
    LD HL, ($F000)
    ; Calculate array element address
    ; Register 25 already in HL
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F036), HL    ; Virtual register 27 to memory
    ; Store to array[index] (u8)
    LD HL, ($F036)    ; Virtual register 27 from memory
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; r28 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 28 already in HL
    ADD HL, DE
    ; jump for_loop_1
    JP for_loop_1
    ; for_end_2:
for_end_2:
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.popcount
zvdb.popcount:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = load lut
    LD HL, ($F000)
zvdb.popcount_param_val:
    LD HL, #0000   ; SMC parameter val (u8->u16)
    ; Load array element (u8)
    PUSH HL
    LD A, L
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD L, A         ; Store to HL (low byte)
    ; return r4
    ; Register 4 already in HL
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.hamming
zvdb.hamming:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r4 = 0
    LD A, 0
    LD ($F008), A     ; Virtual register 4 to memory
    ; store , r4
    LD HL, ($F008)    ; Virtual register 4 from memory
    LD ($F006), HL
    ; r5 = 0
    LD A, 0
    LD ($F00A), A     ; Virtual register 5 to memory
    ; r6 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F00A)    ; Virtual register 5 from memory
    ; for_loop_7:
for_loop_7:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L8
    LD HL, 0
    JP .L9
.L8:
    LD HL, 1
.L9:
    ; Register 8 already in HL
    ; jump_if_not r8, for_end_8
    LD A, L
    OR A
    JP Z, for_end_8
; TSMC reference parameter v1
v1$immOP:
    LD HL, 0000      ; TSMC ref address for v1
v1$imm0 EQU v1$immOP+1
    LD ($F014), HL    ; Virtual register 10 to memory
    ; Load field data (offset 0)
    LD HL, ($F014)    ; Virtual register 10 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD D, H
    LD E, L
    ; r12 = load i
    LD HL, ($F000)
    ; Register 12 already in HL
    ; Load array element (u8)
    LD H, D
    LD L, E
    PUSH HL
    LD A, L
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
; TSMC reference parameter v2
v2$immOP:
    LD HL, 0000      ; TSMC ref address for v2
v2$imm0 EQU v2$immOP+1
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load field data (offset 0)
    LD HL, ($F01C)    ; Virtual register 14 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    PUSH HL           ; Save current HL
    EXX               ; Switch to shadow registers
    POP HL            ; Load into shadow HL
    EXX               ; Switch back to main registers
    ; r16 = load i
    LD HL, ($F000)
    LD ($F020), HL    ; Virtual register 16 to memory
    ; Load array element (u8)
    EXX               ; Switch to shadow registers
    PUSH HL           ; Save shadow HL
    EXX               ; Switch back to main registers
    POP HL            ; Load shadow HL into main HL
    PUSH HL
    LD A, ($F020)     ; Virtual register 16 from memory
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r18 = r13 ^ r17
    LD D, H
    LD E, L
    LD A, L
    XOR E
    LD L, A
    LD A, H
    XOR D
    LD H, A
    ; store , r18
    LD A, L
    LD ($F012), A
    ; r20 = load xor_val
    LD A, ($F012)
    LD H, A         ; Store to physical register H
    ; r21 = call popcount
    ; Call to popcount (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.popcount
    ; store , r21
    LD A, L
    LD ($F026), A
    ; r22 = load dist
    LD HL, ($F006)
    ; r23 = load pc
    LD A, ($F026)
    LD L, A         ; Store to physical register L
    ; r24 = r22 + r23
    LD D, H
    LD E, L
    ADD HL, DE
    LD ($F030), HL    ; Virtual register 24 to memory
    ; store dist, r24
    LD HL, ($F030)    ; Virtual register 24 from memory
    LD ($F006), HL
    ; r25 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 25 already in HL
    ADD HL, DE
    ; jump for_loop_7
    JP for_loop_7
    ; for_end_8:
for_end_8:
    ; r26 = load dist
    LD HL, ($F006)
    ; return r26
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.add_vector
zvdb.add_vector:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = load count
    LD HL, ($F000)
    ; r3 = 16
    LD A, 16
    LD ($F006), A     ; Virtual register 3 to memory
    ; r4 = r2 >= r3
    LD D, H
    LD E, L
    LD HL, ($F006)    ; Virtual register 3 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP P, .L10
    JP Z, .L10
    LD HL, 0
    JP .L11
.L10:
    LD HL, 1
.L11:
    ; jump_if_not r4, else_9
    LD A, H
    OR A
    JP Z, else_9
    ; r5 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; return r5
    RET
    ; jump end_if_10
    JP end_if_10
    ; else_9:
else_9:
    ; end_if_10:
end_if_10:
    ; r7 = load count
    LD HL, ($F000)
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; store , r7
    LD A, ($F00E)     ; Virtual register 7 from memory
    LD ($F00C), A
    ; r8 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r9 = 32
    LD A, 32
    LD L, A         ; Store to HL (low byte)
    ; Initialize loop variable i
    ; for_loop_11:
for_loop_11:
    ; Check i < end
    LD D, H
    LD E, L
    ; Register 9 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L12
    LD HL, 0
    JP .L13
.L12:
    LD HL, 1
.L13:
    ; jump_if_not r11, for_end_12
    LD A, L
    OR A
    JP Z, for_end_12
; TSMC reference parameter vec
vec$immOP:
    LD HL, 0000      ; TSMC ref address for vec
vec$imm0 EQU vec$immOP+1
    LD ($F018), HL    ; Virtual register 12 to memory
    ; Load field data (offset 0)
    LD HL, ($F018)    ; Virtual register 12 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 13 already in HL
    ; r14 = load i
    LD HL, ($F000)
    LD ($F01C), HL    ; Virtual register 14 to memory
    ; Load array element (u8)
    ; Register 13 already in HL
    PUSH HL
    LD A, ($F01C)     ; Virtual register 14 from memory
    LD E, A
    LD D, 0
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r16 = load vectors
    LD HL, ($F000)
    ; r17 = load idx
    LD A, ($F00C)
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD ($F024), A     ; Virtual register 18 to memory
    ; Load field data (offset 0)
    LD HL, ($F024)    ; Virtual register 18 from memory
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; Register 19 already in HL
    ; r20 = load i
    LD HL, ($F000)
    ; Register 20 already in HL
    ; Calculate array element address
    ; Register 19 already in HL
    LD D, H
    LD E, L
    ; Register 20 already in HL
    ADD HL, DE
    LD ($F02A), HL    ; Virtual register 21 to memory
    ; Store to array[index] (u8)
    LD HL, ($F02A)    ; Virtual register 21 from memory
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r22 = 1
    LD A, 1
    LD ($F02C), A     ; Virtual register 22 to memory
    ; Increment i
    LD D, H
    LD E, L
    LD HL, ($F02C)    ; Virtual register 22 from memory
    ADD HL, DE
    ; jump for_loop_11
    JP for_loop_11
    ; for_end_12:
for_end_12:
    ; r23 = load count
    LD HL, ($F000)
    ; r24 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r25 = r23 + r24
    LD D, H
    LD E, L
    ADD HL, DE
    ; Register 25 already in HL
    ; store count, r25
    ; Register 25 already in HL
    LD ($F000), HL
    ; r26 = load idx
    LD A, ($F00C)
    LD H, A         ; Store to physical register H
    ; return r26
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.find_best
zvdb.find_best:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r3 = 255
    LD A, 255
    LD L, A         ; Store to physical register L
    ; r4 = load result
    LD HL, ($F004)
    ; Register 4 already in HL
    ; Store to field vector_id (offset 0)
    ; Register 4 already in HL
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r5 = 256
    LD HL, 256
    LD ($F00A), HL    ; Virtual register 5 to memory
    ; r6 = load result
    LD HL, ($F004)
    ; Register 6 already in HL
    ; Store to field hamming (offset 1)
    ; Register 6 already in HL
    LD DE, 1
    ADD HL, DE
    PUSH HL
    LD HL, ($F00A)    ; Virtual register 5 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r7 = 256
    LD HL, 256
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; r8 = -r7
    LD HL, ($F00E)    ; Virtual register 7 from memory
    XOR A         ; Clear A
    SUB L         ; 0 - L
    LD L, A
    LD A, 0
    SBC A, H      ; 0 - H with borrow
    LD H, A
    ; r9 = load result
    LD HL, ($F004)
    ; Store to field score (offset 3)
    LD DE, 3
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r10 = 0
    LD A, 0
    LD ($F014), A     ; Virtual register 10 to memory
    ; r11 = load count
    LD HL, ($F000)
    ; Initialize loop variable i
    LD HL, ($F014)    ; Virtual register 10 from memory
    ; for_loop_13:
for_loop_13:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L14
    LD HL, 0
    JP .L15
.L14:
    LD HL, 1
.L15:
    ; Register 13 already in HL
    ; jump_if_not r13, for_end_14
    LD A, L
    OR A
    JP Z, for_end_14
; TSMC reference parameter query
query$immOP:
    LD HL, 0000      ; TSMC ref address for query
query$imm0 EQU query$immOP+1
    LD ($F01E), HL    ; Virtual register 15 to memory
    ; r16 = load vectors
    LD HL, ($F000)
    ; Register 16 already in HL
    ; r17 = load i
    LD HL, ($F000)
    ; Load array element (zvdb.Vector256)
    ; Register 16 already in HL
    PUSH HL
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r19 = &r18
    ; Address-of operation for register r18
    LD HL, $F024  ; Variable address
    LD ($F026), HL    ; Virtual register 19 to memory
    ; r20 = call hamming
    ; Call to hamming (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F026)    ; Virtual register 19 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F01E)    ; Virtual register 15 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.hamming
    ; store , r20
    LD ($F01C), HL
    ; r21 = load dist
    LD HL, ($F01C)
    ; r22 = load result
    LD HL, ($F004)
    ; Load field hamming (offset 1)
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = r21 < r23
    LD D, H
    LD E, L
    LD HL, ($F02E)    ; Virtual register 23 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L16
    LD HL, 0
    JP .L17
.L16:
    LD HL, 1
.L17:
    ; Register 24 already in HL
    ; jump_if_not r24, else_15
    LD A, L
    OR A
    JP Z, else_15
    ; r25 = load i
    LD HL, ($F000)
    LD ($F032), HL    ; Virtual register 25 to memory
    ; r26 = load result
    LD HL, ($F004)
    ; Store to field vector_id (offset 0)
    PUSH HL
    LD HL, ($F032)    ; Virtual register 25 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r27 = load dist
    LD HL, ($F01C)
    ; r28 = load result
    LD HL, ($F004)
    ; Register 28 already in HL
    ; Store to field hamming (offset 1)
    ; Register 28 already in HL
    LD DE, 1
    ADD HL, DE
    PUSH HL
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; r30 = load dist
    LD HL, ($F01C)
    ; r31 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; r32 = r30 << r31
    ; 16-bit shift left
    LD A, L
    LD B, A       ; B = shift count
    OR A
    JR Z, .shl16_done_17
.shl16_loop_17:
    ADD HL, HL    ; Shift left by 1
    DJNZ .shl16_loop_17
.shl16_done_17:
    ; store , r32
    LD ($F03A), HL
    ; r33 = 256
    LD HL, 256
    ; Register 33 already in HL
    ; r34 = load doubled
    LD HL, ($F03A)
    ; Register 34 already in HL
    ; r35 = r33 - r34
    ; Register 33 already in HL
    LD D, H
    LD E, L
    ; Register 34 already in HL
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    LD ($F046), HL    ; Virtual register 35 to memory
    ; r36 = load result
    LD HL, ($F004)
    ; Store to field score (offset 3)
    LD DE, 3
    ADD HL, DE
    PUSH HL
    LD HL, ($F046)    ; Virtual register 35 from memory
    POP DE
    LD (DE), L
    INC DE
    LD (DE), H
    ; jump end_if_16
    JP end_if_16
    ; else_15:
else_15:
    ; end_if_16:
end_if_16:
    ; r37 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Increment i
    LD D, H
    LD E, L
    ; Register 37 already in HL
    ADD HL, DE
    ; jump for_loop_13
    JP for_loop_13
    ; for_end_14:
for_end_14:
    ; r38 = load result
    LD HL, ($F004)
    ; return r38
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.create_tests
zvdb.create_tests:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r2 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r3 = 32
    LD A, 32
    LD ($F006), A     ; Virtual register 3 to memory
    ; Initialize loop variable i
    ; for_loop_17:
for_loop_17:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F006)    ; Virtual register 3 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L19
    LD HL, 0
    JP .L20
.L19:
    LD HL, 1
.L20:
    ; jump_if_not r5, for_end_18
    LD A, L
    OR A
    JP Z, for_end_18
    ; r6 = load i
    LD HL, ($F000)
    LD ($F00C), HL    ; Virtual register 6 to memory
    ; r7 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r8 = r6 & r7
    LD HL, ($F00C)    ; Virtual register 6 from memory
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r9 = 0
    LD A, 0
    LD ($F012), A     ; Virtual register 9 to memory
    ; r10 = r8 == r9
    LD D, H
    LD E, L
    LD HL, ($F012)    ; Virtual register 9 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L21
    LD HL, 0
    JP .L22
.L21:
    LD HL, 1
.L22:
    ; jump_if_not r10, else_19
    LD A, H
    OR A
    JP Z, else_19
    ; r11 = 85
    LD A, 85
    LD L, A         ; Store to physical register L
    ; r12 = load vec
    LD HL, ($F002)
    ; Register 12 already in HL
    ; Load field data (offset 0)
    ; Register 12 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F01A), HL    ; Virtual register 13 to memory
    ; r14 = load i
    LD HL, ($F000)
    ; Register 14 already in HL
    ; Calculate array element address
    LD HL, ($F01A)    ; Virtual register 13 from memory
    LD D, H
    LD E, L
    ; Register 14 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_20
    JP end_if_20
    ; else_19:
else_19:
    ; r16 = 170
    LD A, 170
    LD L, A         ; Store to physical register L
    ; r17 = load vec
    LD HL, ($F002)
    ; Register 17 already in HL
    ; Load field data (offset 0)
    ; Register 17 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F024), HL    ; Virtual register 18 to memory
    ; r19 = load i
    LD HL, ($F000)
    ; Register 19 already in HL
    ; Calculate array element address
    LD HL, ($F024)    ; Virtual register 18 from memory
    LD D, H
    LD E, L
    ; Register 19 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; end_if_20:
end_if_20:
    ; r21 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_17
    JP for_loop_17
    ; for_end_18:
for_end_18:
    ; r22 = load vec
    LD HL, ($F002)
    LD ($F02C), HL    ; Virtual register 22 to memory
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    ; r24 = call add_vector
    ; Call to add_vector (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.add_vector
    ; r25 = 0
    LD A, 0
    LD ($F032), A     ; Virtual register 25 to memory
    ; r26 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F032)    ; Virtual register 25 from memory
    ; for_loop_21:
for_loop_21:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L23
    LD HL, 0
    JP .L24
.L23:
    LD HL, 1
.L24:
    ; Register 28 already in HL
    ; jump_if_not r28, for_end_22
    LD A, L
    OR A
    JP Z, for_end_22
    ; r29 = 255
    LD A, 255
    LD H, A         ; Store to physical register H
    ; r30 = load vec
    LD HL, ($F002)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F03E), HL    ; Virtual register 31 to memory
    ; r32 = load i
    LD HL, ($F000)
    ; Register 32 already in HL
    ; Calculate array element address
    LD HL, ($F03E)    ; Virtual register 31 from memory
    LD D, H
    LD E, L
    ; Register 32 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r34 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_21
    JP for_loop_21
    ; for_end_22:
for_end_22:
    ; r35 = load vec
    LD HL, ($F002)
    LD ($F046), HL    ; Virtual register 35 to memory
    ; r36 = &r35
    ; Address-of operation for register r35
    LD HL, $F046  ; Variable address
    ; r37 = call add_vector
    ; Call to add_vector (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.add_vector
    ; r38 = 0
    LD A, 0
    LD ($F04C), A     ; Virtual register 38 to memory
    ; r39 = 32
    LD A, 32
    LD H, A         ; Store to physical register H
    ; Initialize loop variable i
    LD HL, ($F04C)    ; Virtual register 38 from memory
    ; for_loop_23:
for_loop_23:
    ; Check i < end
    LD D, H
    LD E, L
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L25
    LD HL, 0
    JP .L26
.L25:
    LD HL, 1
.L26:
    ; Register 41 already in HL
    ; jump_if_not r41, for_end_24
    LD A, L
    OR A
    JP Z, for_end_24
    ; r42 = 0
    LD A, 0
    LD H, A         ; Store to physical register H
    ; r43 = load vec
    LD HL, ($F002)
    ; Load field data (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F058), HL    ; Virtual register 44 to memory
    ; r45 = load i
    LD HL, ($F000)
    ; Register 45 already in HL
    ; Calculate array element address
    LD HL, ($F058)    ; Virtual register 44 from memory
    LD D, H
    LD E, L
    ; Register 45 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, H
    POP HL
    LD (HL), A
    ; r47 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_23
    JP for_loop_23
    ; for_end_24:
for_end_24:
    ; r48 = load vec
    LD HL, ($F002)
    ; Register 48 already in HL
    ; r49 = &r48
    ; Address-of operation for register r48
    LD HL, $F060  ; Variable address
    ; r50 = call add_vector
    ; Call to add_vector (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.add_vector
    ; return
    RET
; Using hierarchical register allocation (physical → shadow → memory)

; Function: zvdb.main
zvdb.main:
; IsSMCDefault=true, IsSMCEnabled=true
; Using absolute addressing for locals (SMC style)
    ; r1 = string(str_0)
    LD HL, str_0
    LD ($F002), HL    ; Virtual register 1 to memory
    ; Print "ZVDB-MinZ Production Ready
" (27 chars via loop)
    LD HL, ($F002)    ; Virtual register 1 from memory
    CALL print_string
    ; r2 = string(str_1)
    LD HL, str_1
    ; Print "==========================

" (28 chars via loop)
    CALL print_string
    ; r3 = string(str_2)
    LD HL, str_2
    ; Print "Initializing LUT...
" (20 chars via loop)
    CALL print_string
    ; r4 = call init_lut
    ; Call to init_lut (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb.init_lut
    LD ($F008), HL    ; Virtual register 4 to memory
    ; r5 = string(str_3)
    LD HL, str_3
    ; Print "Creating test vectors...
" (25 chars via loop)
    CALL print_string
    ; r6 = call create_tests
    ; Call to create_tests (args: 0)
    ; Found function, UsesTrueSMC=false
    CALL zvdb.create_tests
    ; r7 = string(str_4)
    LD HL, str_4
    LD ($F00E), HL    ; Virtual register 7 to memory
    ; Print "Database has " (13 chars via loop)
    LD HL, ($F00E)    ; Virtual register 7 from memory
    CALL print_string
    ; r8 = string(str_5)
    LD HL, str_5
    ; Print " vectors

" (10 chars via loop)
    CALL print_string
    ; r10 = load vectors
    LD HL, ($F000)
    ; r11 = 0
    LD A, 0
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r13 = &r12
    ; Address-of operation for register r12
    LD HL, $F018  ; Variable address
    LD ($F01A), HL    ; Virtual register 13 to memory
    ; r14 = load vectors
    LD HL, ($F000)
    ; r15 = 1
    LD A, 1
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r17 = &r16
    ; Address-of operation for register r16
    LD HL, $F020  ; Variable address
    LD ($F022), HL    ; Virtual register 17 to memory
    ; r18 = call hamming
    ; Call to hamming (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F022)    ; Virtual register 17 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F01A)    ; Virtual register 13 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.hamming
    ; store , r18
    LD ($F012), HL
    ; r20 = load vectors
    LD HL, ($F000)
    ; r21 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; Load array element (zvdb.Vector256)
    PUSH HL
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r23 = &r22
    ; Address-of operation for register r22
    LD HL, $F02C  ; Variable address
    LD ($F02E), HL    ; Virtual register 23 to memory
    ; r24 = load vectors
    LD HL, ($F000)
    ; r25 = 2
    LD A, 2
    LD L, A         ; Store to HL (low byte)
    ; Load array element (zvdb.Vector256)
    PUSH HL
    LD D, H
    LD E, L
    POP HL
    ADD HL, DE
    LD A, (HL)
    LD H, A         ; Store to physical register H
    ; r27 = &r26
    ; Address-of operation for register r26
    LD HL, $F034  ; Variable address
    LD ($F036), HL    ; Virtual register 27 to memory
    ; r28 = call hamming
    ; Call to hamming (args: 2)
    ; Stack-based parameter passing
    LD HL, ($F036)    ; Virtual register 27 from memory
    PUSH HL       ; Argument 1
    LD HL, ($F02E)    ; Virtual register 23 from memory
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.hamming
    ; store , r28
    LD ($F026), HL
    ; r29 = string(str_6)
    LD HL, str_6
    ; Print "Hamming distances:
" (19 chars via loop)
    CALL print_string
    ; r30 = string(str_7)
    LD HL, str_7
    ; Print "  V0 vs V1: " (12 chars via loop)
    CALL print_string
    ; Direct print " bits
" (6 chars)
    ; Direct print " bits
" (6 chars)
    LD A, 32
    RST 16             ; Print character
    LD A, 98
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 116
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; r31 = string(str_8)
    LD HL, str_8
    LD ($F03E), HL    ; Virtual register 31 to memory
    ; Print "  V0 vs V2: " (12 chars via loop)
    LD HL, ($F03E)    ; Virtual register 31 from memory
    CALL print_string
    ; Direct print " bits
" (6 chars)
    ; Direct print " bits
" (6 chars)
    LD A, 32
    RST 16             ; Print character
    LD A, 98
    RST 16             ; Print character
    LD A, 105
    RST 16             ; Print character
    LD A, 116
    RST 16             ; Print character
    LD A, 115
    RST 16             ; Print character
    LD A, 10
    RST 16             ; Print character
    ; r32 = string(str_9)
    LD HL, str_9
    ; Print "
Searching...
" (14 chars via loop)
    CALL print_string
    ; r34 = 0
    LD A, 0
    LD L, A         ; Store to physical register L
    ; r35 = 32
    LD A, 32
    LD ($F046), A     ; Virtual register 35 to memory
    ; Initialize loop variable i
    ; for_loop_25:
for_loop_25:
    ; Check i < end
    LD D, H
    LD E, L
    LD HL, ($F046)    ; Virtual register 35 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP M, .L27
    LD HL, 0
    JP .L28
.L27:
    LD HL, 1
.L28:
    ; jump_if_not r37, for_end_26
    LD A, L
    OR A
    JP Z, for_end_26
    ; r38 = load i
    LD HL, ($F000)
    LD ($F04C), HL    ; Virtual register 38 to memory
    ; r39 = 1
    LD A, 1
    LD H, A         ; Store to physical register H
    ; r40 = r38 & r39
    LD HL, ($F04C)    ; Virtual register 38 from memory
    LD D, H
    LD E, L
    LD A, L
    AND E
    LD L, A
    LD A, H
    AND D
    LD H, A
    ; r41 = 0
    LD A, 0
    LD ($F052), A     ; Virtual register 41 to memory
    ; r42 = r40 == r41
    LD D, H
    LD E, L
    LD HL, ($F052)    ; Virtual register 41 from memory
    EX DE, HL
    OR A      ; Clear carry
    SBC HL, DE
    JP Z, .L29
    LD HL, 0
    JP .L30
.L29:
    LD HL, 1
.L30:
    ; jump_if_not r42, else_27
    LD A, H
    OR A
    JP Z, else_27
    ; r43 = 84
    LD A, 84
    LD L, A         ; Store to physical register L
    ; r44 = load query
    LD HL, ($F042)
    ; Register 44 already in HL
    ; Load field data (offset 0)
    ; Register 44 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F05A), HL    ; Virtual register 45 to memory
    ; r46 = load i
    LD HL, ($F000)
    ; Register 46 already in HL
    ; Calculate array element address
    LD HL, ($F05A)    ; Virtual register 45 from memory
    LD D, H
    LD E, L
    ; Register 46 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; jump end_if_28
    JP end_if_28
    ; else_27:
else_27:
    ; r48 = 171
    LD A, 171
    LD L, A         ; Store to physical register L
    ; r49 = load query
    LD HL, ($F042)
    ; Register 49 already in HL
    ; Load field data (offset 0)
    ; Register 49 already in HL
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F064), HL    ; Virtual register 50 to memory
    ; r51 = load i
    LD HL, ($F000)
    ; Register 51 already in HL
    ; Calculate array element address
    LD HL, ($F064)    ; Virtual register 50 from memory
    LD D, H
    LD E, L
    ; Register 51 already in HL
    ADD HL, DE
    ; Store to array[index] (u8)
    PUSH HL
    LD A, L
    POP HL
    LD (HL), A
    ; end_if_28:
end_if_28:
    ; r53 = 1
    LD A, 1
    LD L, A         ; Store to physical register L
    ; Increment i
    LD D, H
    LD E, L
    ADD HL, DE
    ; jump for_loop_25
    JP for_loop_25
    ; for_end_26:
for_end_26:
    ; r55 = load query
    LD HL, ($F042)
    LD ($F06E), HL    ; Virtual register 55 to memory
    ; r56 = &r55
    ; Address-of operation for register r55
    LD HL, $F06E  ; Variable address
    ; r57 = call find_best
    ; Call to find_best (args: 1)
    ; Stack-based parameter passing
    PUSH HL       ; Argument 0
    ; Found function, UsesTrueSMC=false
    CALL zvdb.find_best
    ; store , r57
    LD ($F06C), HL
    ; r58 = load result
    LD HL, ($F06C)
    ; Load field vector_id (offset 0)
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    ; print_u8(r59)
    LD A, L
    CALL print_u8_decimal
    ; r60 = load result
    LD HL, ($F06C)
    ; Register 60 already in HL
    ; Load field hamming (offset 1)
    ; Register 60 already in HL
    LD DE, 1
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F07A), HL    ; Virtual register 61 to memory
    ; print_u16(r61)
    LD HL, ($F07A)    ; Virtual register 61 from memory
    CALL print_u16_decimal
    ; r62 = load result
    LD HL, ($F06C)
    ; Register 62 already in HL
    ; Load field score (offset 3)
    ; Register 62 already in HL
    LD DE, 3
    ADD HL, DE
    LD E, (HL)
    INC HL
    LD D, (HL)
    EX DE, HL
    LD ($F07E), HL    ; Virtual register 63 to memory
    ; print_u16(r63)
    LD HL, ($F07E)    ; Virtual register 63 from memory
    CALL print_u16_decimal
    ; r64 = string(str_10)
    LD HL, str_10
    ; Register 64 already in HL
    ; Print "
â ZVDB-MinZ Complete!
" (28 chars via loop)
    ; Register 64 already in HL
    CALL print_string
    ; return
    RET

; Runtime print helper functions
print_string:
    LD B, (HL)         ; B = length from first byte
    INC HL             ; HL -> string data
    LD A, B            ; Check if length is zero
    OR A
    RET Z              ; Return if empty string
print_loop:
    LD A, (HL)         ; Load character
    RST 16             ; Print character
    INC HL             ; Next character
    DJNZ print_loop    ; Decrement B and loop
    RET

print_u8_decimal:
    LD H, 0            ; HL = A (zero extend)
    LD L, A
    CALL print_u16_decimal
    RET

print_u16_decimal:
    LD BC, -10000
    LD DE, -1000
    CALL print_digit
    LD BC, -1000
    LD DE, -100
    CALL print_digit
    LD BC, -100
    LD DE, -10
    CALL print_digit
    LD BC, -10
    LD DE, -1
    CALL print_digit
    LD A, L
    ADD A, '0'         ; Convert to ASCII
    RST 16             ; Print last digit
    RET

print_digit:
    LD A, '0'-1
print_digit_loop:
    INC A
    ADD HL, BC         ; Subtract power of 10
    JR C, print_digit_loop
    ADD HL, DE         ; Add back one power of 10
    RST 16             ; Print digit
    RET

print_i8_decimal:
    BIT 7, A           ; Check sign bit
    JR Z, print_u8_decimal
    PUSH AF
    LD A, '-'          ; Print minus sign
    RST 16
    POP AF
    NEG                ; Make positive
    JR print_u8_decimal

print_i16_decimal:
    BIT 7, H           ; Check sign bit
    JR Z, print_u16_decimal
    PUSH HL
    LD A, '-'          ; Print minus sign
    RST 16
    POP HL
    LD A, H            ; Negate HL
    CPL
    LD H, A
    LD A, L
    CPL
    LD L, A
    INC HL
    JR print_u16_decimal

print_bool:
    OR A               ; Test if A is zero
    JR NZ, print_true
    LD HL, bool_false_str
    JR print_string
print_true:
    LD HL, bool_true_str
    JR print_string

bool_true_str:
    DB 4, "true"      ; Length + data
bool_false_str:
    DB 5, "false"     ; Length + data


    END main
