// ZVDB: 256-bit Vector Database in MinZ
// =======================================
// A complete 1-bit quantized vector database for Z80 hardware
// Features: 256-bit vectors, popcount LUT, similarity search
// Performance: 3.8x faster than hand-written assembly
// See ZVDB_README.md for benchmarks and technical details

const VECTOR_BYTES: u8 = 32;
const MAX_VECTORS: u8 = 16;

struct Vector256 {
    data: [u8; 32]
}

struct SearchResult {
    vector_id: u8,
    hamming: u16,
    score: i16
}

// Global database
var vectors: [Vector256; 16];
var count: u8 = 0;
var lut: [u8; 256];  // Popcount lookup table

// Initialize popcount LUT
fn init_lut() -> void {
    for i in 0..256 {
        let val: u8 = i as u8;
        let bits: u8 = 0;
        
        // Count bits
        for b in 0..8 {
            if (val & (1 << b)) != 0 {
                bits = bits + 1;
            }
        }
        
        lut[i] = bits;
    }
}

// Fast popcount
fn popcount(val: u8) -> u8 {
    return lut[val];
}

// Hamming distance between vectors
fn hamming(v1: *Vector256, v2: *Vector256) -> u16 {
    let dist: u16 = 0;
    
    for i in 0..VECTOR_BYTES {
        let xor_val: u8 = v1.data[i] ^ v2.data[i];
        let pc: u8 = popcount(xor_val);
        dist = dist + pc as u16;
    }
    
    return dist;
}

// Add vector to database
fn add_vector(vec: *Vector256) -> u8 {
    if count >= MAX_VECTORS {
        return 255;
    }
    
    let idx: u8 = count;
    
    // Copy vector
    for i in 0..VECTOR_BYTES {
        vectors[idx].data[i] = vec.data[i];
    }
    
    count = count + 1;
    return idx;
}

// Find best match
fn find_best(query: *Vector256) -> SearchResult {
    let result: SearchResult;
    result.vector_id = 255;
    result.hamming = 256;
    result.score = -256;
    
    for i in 0..count {
        let dist: u16 = hamming(query, &vectors[i]);
        if dist < result.hamming {
            result.vector_id = i;
            result.hamming = dist;
            let doubled: u16 = dist << 1;
            result.score = 256 - doubled as i16;
        }
    }
    
    return result;
}

// Create test data
fn create_tests() -> void {
    let vec: Vector256;
    
    // Vector 0: Pattern
    for i in 0..VECTOR_BYTES {
        if (i & 1) == 0 {
            vec.data[i] = 0x55;
        } else {
            vec.data[i] = 0xAA;
        }
    }
    add_vector(&vec);
    
    // Vector 1: All ones
    for i in 0..VECTOR_BYTES {
        vec.data[i] = 0xFF;
    }
    add_vector(&vec);
    
    // Vector 2: All zeros
    for i in 0..VECTOR_BYTES {
        vec.data[i] = 0x00;
    }
    add_vector(&vec);
}

fn main() -> void {
    @print("ZVDB-MinZ Production Ready\n");
    @print("==========================\n\n");
    
    // Initialize
    @print("Initializing LUT...\n");
    init_lut();
    
    @print("Creating test vectors...\n");
    create_tests();
    
    @print("Database has {} vectors\n\n", count);
    
    // Test similarity
    let h01: u16 = hamming(&vectors[0], &vectors[1]);
    let h02: u16 = hamming(&vectors[0], &vectors[2]);
    
    @print("Hamming distances:\n");
    @print("  V0 vs V1: {} bits\n", h01);
    @print("  V0 vs V2: {} bits\n", h02);
    
    // Search test
    @print("\nSearching...\n");
    let query: Vector256;
    for i in 0..VECTOR_BYTES {
        if (i & 1) == 0 {
            query.data[i] = 0x54;
        } else {
            query.data[i] = 0xAB;
        }
    }
    
    let result: SearchResult = find_best(&query);
    @print("Best match: Vector {}\n", result.vector_id);
    @print("Hamming: {} bits\n", result.hamming);
    @print("Score: {}\n", result.score);
    
    @print("\nâœ… ZVDB-MinZ Complete!\n");
}